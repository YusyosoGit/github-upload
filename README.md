# 整列アルゴリズム
## 基本的な整列アルゴリズム

- バブルソート<br>
    隣り合う要素の値を比較し、大小関係が逆順となっていれば交換する。この比較・交換の操作を必要がなくなるまで繰り返す。**隣接交換法**ともいう。計算量はO(n^2)

- 単純選択法<br>
    未整列の要素の中から最も小さい（大きい）要素を選択し、未整列部分の戦闘の要素と入れ替える。この操作を最後から２番めの場所に正しい要素が入るまで繰り返す。**最小値（最大値）選択法**ともいう。計算量はO(n^2)

- 単純挿入法<br>
    未整列要素の並びの先頭の要素を取り出し、その要素を整列済みの要素の中の正しい位置に挿入していく。平均および最悪がO(n^2)。最良の場合はO(n)

- シェルソート<br>
    ある一定間隔おきに取り出した要素からなる部分列をそれぞれ単純挿入法で整列し、さらに間隔を詰めて同様の操作を行い、間隔が１になるまで繰り返す。**改良挿入法**とも言う。最悪O(n^2)、最良O(nlog2n)

## 高度な整列アルゴリズム
- クイックソート<br>
    分割統治の考え方を利用した整列法で、高速に整列できるが、安定ではなく、分割のアルゴリズムに再帰処理を利用しているところに特徴がある。
    平均計算量はO(nlog2n)、予め整列したデータに対して、最大値または最小値を基準値とした場合の計算量は最悪のO(n^2)

- ヒープソート<br>
    降順の場合では、まず未整列のデータをヒープ(heap)と呼ばれる各節の値に「親が持つデータ＜＝子が持つデータ」という関係を持たせた順序木に作成し、これを配列で表現する。そして、ヒープの根(配列の先頭)となった最小値を取り出し、整列済みの部分に移し、ヒープを再構成する。ヒープはこのような「根(最小値)の取り出し」→「ヒープ再構成」という操作を繰り返して、未整列部分を徐々に縮めていく整列法である。高速に動作するが、安定ではないという特徴がある。<br>
    計算量はO(nlog2n)となる。

- マージソート<br>
    整列対象データ列の分割と併合(マージ)を繰り返して、最終的に１つの整列済みデータ列を作る整列法。
    分割統治の考え方を利用した整列法で、分割・併合のアルゴリズムに再帰処理を利用するが、安定で、データ数の半分程度の作業領域を必要とするという特徴がある。<br>
    なお、計算量はO(nlog2n)となる。


